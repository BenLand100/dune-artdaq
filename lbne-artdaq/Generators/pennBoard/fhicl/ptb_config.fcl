 # No idea of the whole block below means
 daq: {
  max_fragment_size_words: 1048576
  fragment_receiver: {
    mpi_buffer_count: 16
    first_event_builder_rank: 1
    event_builder_count: 2

    generator: PennReceiver
    fragment_type: PENN
    fragment_id: 0
    board_id: 0
    sleep_on_stop_us: 500000
 	
 	  # The real configuration options for the PTB
   	penn_client_host_addr     : '192.168.1.2' # the IP of the PTB
  	penn_client_host_port     : 8991 		# client port
  	penn_client_timeout_usecs : 5E5 		# connection timeout. THis is a board_reader option
  		
    #
    # Board reader options. No idea of what they mean
  	#
  	
  	# No idea of what these mean
   	receiver_tick_period_usecs    : 1E4
   	millislice_size               : 10
   	millislice_overlap_size       : 5
   	receiver_debug_level          : 0   # higher number = print more info (6 is current highest level)
  	reporting_interval_fragments  : 10
  	reporting_interval_time       : 0
  	
   	raw_buffer_size             : 4000000
   	raw_buffer_precommit        : 50
   	use_fragments_as_raw_buffer : true     # false not currently implemented
  	
  	#
  	# Emulator options. Same as before. Seems a bit cryptic
  	#
  		
  	penn_data_num_millislices   : 1         # 0=Run until stopped
   	penn_data_num_microslices   : 1000
   	penn_data_frag_rate         : 1000      # Hz
   	
   	# Same for these -- what to these mean?
  	penn_data_payload_mode 			: 2         # counter&trigger payload contents 0=all off, 1=all on, 2=alternating on/off, 3=random
  	penn_data_trigger_mode      : 2         # 0=no trigger words sent. 1=trigger word sent every tick. 2=trigger word sent randomly
  
   	penn_data_fragment_microslice_at_ticks : 0         #after this many ticks the uslice will be fragmented (<=0 means fragment automatically based on size)
   	
  	penn_data_repeat_microslices           : false     #for rate testing
   	penn_data_debug_partial_recv           : false     #slows emulator down to send 1 byte at a time, every 0.1 seconds. For testing how the boardreader handles async_receive that grabs less than requested bytes
   	
   	
   	#
   	# PTB configuration options
   	#
   	
   	penn_data_buffer : {
      daq_host            : "lbnedaq5"
      daq_port            : 8992
      daq_rollover 	      : 80 			# Number of packets before the slice is considered ready. Probably not needed.
      daq_microslice_size	: 7			# There are (2^x)-1 clock ticks per microslice. This is a time based rollover
    }
  
    channel_mask : {
      BSU	: 0x1FFFFFFFFFFFF		# All 49 channels are ON
      TSU : 0xFFFFFFFFFFFF		# All 48 channels are ON 
    }
  
    muon_triggers : {
      trig_out_width: 2						# Number of clock ticks that the trigger out pulse is high
      trig_window		: 3						# Number of clock ticks that the input signal is stretched to account for time offsets between panels
      trig_lockdown	: 11					# Number of clock ticks that the input signal is locked low after being high. Accounts for reflections.
      num_triggers	: 4						# Number of different trigger masks
  
      trigger_0 : {
        id      : "A"					# Just something for debugging purposes
        id_mask	: "1000"				# Not used at the moment. Same ID as the IP in the PL
        logic		: 0						# Logic to be applied between groups (0: AND, 1: OR, 2: XOR) 
        prescale: 0						# Number of triggers that are ignored after a successful trigger
        group1 : {
          logic	: 2						# XOR
          BSU		: 0xFFFF				# BSU mask (RM 1-16)
          TSU		: 0x0					# TSU mask
        }
        group2 : {
          logic	: 2						# AND
          BSU		: 0x7F7E000000			# BSU mask (CL 1-13)
          TSU		: 0x0					# TSU mask
        }			    
      }
  
      trigger_1 : {
        id			: "B"					# Just something for debugging purposes
        id_mask	: "0100"				# Not used at the moment. Same ID as the IP in the PL
        logic		: 0						# Logic to be applied between groups (0: AND, 1: OR, 2: XOR) 
        prescale: 0						# Number of triggers that are ignored after a successful trigger
        group1 : {
          logic	: 1						# XOR
          BSU		: 0x0					# BSU mask
          TSU		: 0x3F000000			# TSU mask (NU 1-6)
        }
        group2 : {
          logic	: 1						# AND
          BSU		: 0x0					# BSU mask
          TSU		: 0xFC0000000			# TSU mask (SL 1-6)
        }			    
      }
  
      trigger_2 : {
        id			: "C"					# Just something for debugging purposes
        id_mask	: "0010"				# Not used at the moment. Same ID as the IP in the PL
        logic		: 0						# Logic to be applied between groups (0: AND, 1: OR, 2: XOR) 
        prescale: 0						# Number of triggers that are ignored after a successful trigger
        group1 : {
          logic	: 1						# XOR
          BSU		: 0x0					# BSU mask
          TSU		: 0xFC0000000000		# TSU mask (SU 1-6)
        }
        group2 : {
          logic	: 1						# AND
          BSU		: 0x0					# BSU mask
          TSU		: 0x3F000000000			# TSU mask (NL 1-6)
        }			    
      }
  
      trigger_3 : {
        id			: "D"					# Just something for debugging purposes
        id_mask	: "0001"				# Not used at the moment. Same ID as the IP in the PL
        logic		: 0						# Logic to be applied between groups (0: AND, 1: OR, 2: XOR) 
        prescale: 0						# Number of triggers that are ignored after a successful trigger
        group1 : {
          logic	: 1						# XOR
          BSU		: 0x0					# BSU mask
          TSU		: 0x7FE00				# TSU mask (EL 1-10)
        }
        group2 : {
          logic	: 1						# AND
          BSU		: 0x0					# BSU mask
          TSU		: 0x1FF					# TSU mask (WU 1-10)
        }			    
      }
    }
  
    external_triggers : {
      mask          : 0x1F					# Mask the external triggers (receiving). There are 4 independent + 8 ored (total of 5 bits) 
      echo_triggers : true					# Should a trigger be sent back to the other systems?
      echo_width    : 2						# Number of clock ticks the pulse should be high
    }	
  
    calibration : {
      period      : 10					# Number of clock ticks between calibration pulse
      channel_mask: 0xF					# There are 4 independent channels. Which should receive the calibration pulse?
      pulse_width	: 2						# Number of clock ticks the pulse should be high
    }
  }
}