////////////////////////////////////////////////////////////////////////
// Class:       PennBoardTrigger
// Module Type: filter
// File:        PennBoardTrigger_module.cc
//
// Generated at Fri Dec  5 10:21:00 2014 by Jonathan Davies using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include <iostream>

#include "artdaq-core/Data/Fragments.hh"
#include "lbne-artdaq/OnlineMonitoring/DataReformatter.h"

namespace trig {
  class PennBoardTrigger;
}

class trig::PennBoardTrigger : public art::EDFilter {
public:
  explicit PennBoardTrigger(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PennBoardTrigger(PennBoardTrigger const &) = delete;
  PennBoardTrigger(PennBoardTrigger &&) = delete;
  PennBoardTrigger & operator = (PennBoardTrigger const &) = delete;
  PennBoardTrigger & operator = (PennBoardTrigger &&) = delete;
  void beginJob();
  void printPennFragInfo( art::Handle<artdaq::Fragments> const & rawPTB);

  // Required functions.
  bool filter(art::Event & evt) override;
  void printParams();

private:

  bool fIsPTB; 
  std::string fPTBModuleLabel;
  std::string fPTBInstanceName;

};


void trig::PennBoardTrigger::beginJob(){
  printParams();
}

trig::PennBoardTrigger::PennBoardTrigger(fhicl::ParameterSet const & p)
// Initialize member data here.
{

  fPTBModuleLabel = p.get<std::string>("PTBModuleLabel", "daq");
  fPTBInstanceName = p.get<std::string>("PTBInstanceName", "TRIGGER");
}

void trig::PennBoardTrigger::printParams(){
  
  for(int i=0;i<80;i++) std::cerr << "=";
  std::cerr << std::endl;
  std::cerr << "fPTBModuleLabel: " << fPTBModuleLabel << std::endl;
  std::cerr << "fPTBInstanceName: " << fPTBInstanceName << std::endl;
  for(int i=0;i<80;i++) std::cerr << "=";
  std::cerr << std::endl;


}

bool trig::PennBoardTrigger::filter(art::Event & evt)
{
  // Implementation of required member function here.
  auto eventID = evt.id();

  art::Handle<artdaq::Fragments> rawPTB;
  fIsPTB=true;
  evt.getByLabel("daq","TRIGGER",rawPTB);
  //  evt.getByLabel(fPTBModuleLabel,fPTBInstanceName,rawPTB);

  if(rawPTB.isValid()){
    std::cerr << "INFO : Got Valid PTB fragments" << std::endl;
    std::cerr << "INFO : Got PTB art::Handle<artdaq::Fragments>" << std::endl;
    std::cerr << "INFO : eventID: " << eventID << std::endl;
    std::cerr << std::endl;
    printPennFragInfo(rawPTB);
    std::cerr << std::endl;
  }
  else{
    std::cerr << "INFO : NOT Got Valid PTB fragments" << std::endl;
  }

  // // PTB 
  //  OnlineMonitoring::PTBFormatter ptbformatter(rawPTB);
  




  return 1;
}

void trig::PennBoardTrigger::printPennFragInfo( art::Handle<artdaq::Fragments> const & rawPTB){

  std::cerr << "Found " << rawPTB->size() << " fragment(s) of type " << fPTBInstanceName << std::endl;

  for (size_t frag_index=0; frag_index < rawPTB->size(); ++frag_index){
    const auto & frag((*rawPTB)[frag_index]); //Make a fragment from the frag_index element of rawPTB

    //    std::cerr << "JPD 1: Making PennMilliSliceFragment" << std::endl;
    lbne::PennMilliSliceFragment ms_frag(frag);
    //Get the number of each payload type in the millislice


    lbne::PennMilliSlice::Header::payload_count_t n_frames, n_frames_counter, n_frames_trigger, n_frames_timestamp;
    //    std::cerr << "JPD 2: Getting payloadCount" << std::endl;
    n_frames = ms_frag.payloadCount(n_frames_counter, n_frames_trigger, n_frames_timestamp);
    

    std::cerr << "Fragment " << frag.fragmentID() 
              << " with version " << ms_frag.version()
              << " and sequence ID " << ms_frag.sequenceID()
              << " consists of: " << ms_frag.size() << " bytes containing "
      //              << ms_frag.microSliceCount() << " microslices and" 
              << std::endl;
    std::cerr << n_frames << " total words ("
              << n_frames_counter << " counter + "
              << n_frames_trigger << " trigger + "
              << n_frames_timestamp << " timestamp + "
              << n_frames - (n_frames_counter + n_frames_trigger + n_frames_timestamp) << " selftest & checksum)"
              << std::endl;

    std::cerr << " with width " << ms_frag.widthTicks() 
              << " ticks (excluding overlap of " << ms_frag.overlapTicks()
              << " ticks_ and end timestamp " << ms_frag.endTimestamp() << std::endl;


    //Now we need to grab the payload informaation in the millislice
    lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type;
    lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp;
    uint8_t* payload_data;
    size_t payload_size;

    //iterate through the frames
    for (uint32_t payload_index = 0; payload_index < n_frames; payload_index++){
      //Get the actual payload



      //      std::cerr << "JPD 3: Getting payload from ms_frag" << std::endl;
      payload_data = ms_frag.payload(payload_index, payload_type, timestamp, payload_size);
      std::cerr << "payload_index: " << std::dec << payload_index
                << " payload_size: " << std::dec << payload_size
                << " timestamp: 0x" << std::hex << timestamp << std::dec;


      if ((payload_data == nullptr) || (payload_size == 0 )){
        std::cerr << std::endl;
        continue;
      }
      //      if (!((payload_data != nullptr) && payload_size)) continue; //I think that this is the logic above
      
      std::cerr << "JPD 4: Printing info about payload_types" << std::endl;
      

      switch ( payload_type )
        {
        case lbne::PennMicroSlice::DataTypeCounter:
          std::cerr << " payload_type: Counter" << std::endl;
          break;
        case lbne::PennMicroSlice::DataTypeTrigger:
          std::cerr << " payload_type: Trigger" << std::endl;
          break;
        case lbne::PennMicroSlice::DataTypeTimestamp:
          std::cerr << " payload_type: Timestamp" << std::endl;
          break;
        case lbne::PennMicroSlice::DataTypeSelftest:
          std::cerr << " payload_type: Selftest" << std::endl;
          break;
        case lbne::PennMicroSlice::DataTypeChecksum:
          std::cerr << " payload_type: Checksum" << std::endl;
          break;
        default:
          std::cerr << " payload_type: Unknown" << std::endl;
          break;
        }//switch(payload_type)
      


      
    }//payload_index



  }//frag_index

  
  
}//printPennFragInfo

DEFINE_ART_MODULE(trig::PennBoardTrigger)
