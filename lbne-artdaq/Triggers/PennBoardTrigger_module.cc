////////////////////////////////////////////////////////////////////////
// Class:       PennBoardTrigger
// Module Type: filter
// File:        PennBoardTrigger_module.cc
//
// Generated at Fri Dec  5 10:21:00 2014 by Jonathan Davies using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <iomanip>
#include <bitset>
#include <sstream>

#include "artdaq-core/Data/Fragments.hh"
#include "lbne-raw-data/Overlays/PennMilliSliceFragment.hh"
#include "lbne-raw-data/Overlays/Utilities.hh"

namespace trig {
  class PennBoardTrigger;
}

class trig::PennBoardTrigger : public art::EDFilter {
public:
  explicit PennBoardTrigger(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PennBoardTrigger(PennBoardTrigger const &) = delete;
  PennBoardTrigger(PennBoardTrigger &&) = delete;
  PennBoardTrigger & operator = (PennBoardTrigger const &) = delete;
  PennBoardTrigger & operator = (PennBoardTrigger &&) = delete;
  void beginJob();
  void checkGetNextPayload(art::Handle<artdaq::Fragments> const & rawPTB);
  void printPayloadInfo(art::Handle<artdaq::Fragments> const & rawPTB);
  bool filterOnTriggerPayload(art::Handle<artdaq::Fragments> const & rawPTB);
  bool filterOnCounterPayload(art::Handle<artdaq::Fragments> const & rawPTB);

  // Required functions.
  bool filter(art::Event & evt) override;
  void printParams();

private:

  bool fPassAllEvents;             //This does not affect whether we insert a boolean result and what that is
  std::string fPTBModuleLabel;     
  std::string fPTBInstanceName;
  bool fVerbose;
  bool fPrintPayloadInfo;
  bool fInsertTriggerResultBool;   //Add a boolean to event with the trigger decision
  bool fInvertTriggerDecision;     //Return the opposite of the trigger decision (over-riden bt fPassAllEvents)

  bool fFilterOnTriggerType;
  lbne::PennMicroSlice::Payload_Trigger::trigger_type_t fTriggerType;
  std::string fTriggerTypeName;

  bool fFilterOnTriggerPattern;
  lbne::PennMicroSlice::Payload_Trigger::trigger_type_t fTriggerPatternBit;
  std::string fTriggerPatternBitName;

  bool fFilterOnCounterPattern;
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_wu>    fCounter_Pattern_bitset_tsu_wu   ;//10
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_el>    fCounter_Pattern_bitset_tsu_el   ;//10
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_extra> fCounter_Pattern_bitset_tsu_extra;// 4
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nu>    fCounter_Pattern_bitset_tsu_nu   ;// 6
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_sl>    fCounter_Pattern_bitset_tsu_sl   ;// 6
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nl>    fCounter_Pattern_bitset_tsu_nl   ;// 6
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_su>    fCounter_Pattern_bitset_tsu_su   ;// 6
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rm>    fCounter_Pattern_bitset_bsu_rm   ;//16
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cu>    fCounter_Pattern_bitset_bsu_cu   ;//10
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cl>    fCounter_Pattern_bitset_bsu_cl   ;//13
  std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rl>    fCounter_Pattern_bitset_bsu_rl   ;//10

  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_tsu_wu   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_tsu_el   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_tsu_extra;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_tsu_nu   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_tsu_sl   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_tsu_nl   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_tsu_su   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_bsu_rm   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_bsu_cu   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_bsu_cl   ;
  lbne::PennMicroSlice::Payload_Counter::counter_set_t fCounter_Pattern_bsu_rl   ;
};


void trig::PennBoardTrigger::beginJob(){
  printParams();
}

trig::PennBoardTrigger::PennBoardTrigger(fhicl::ParameterSet const & p)
// Initialize member data here.
{
  fPassAllEvents = p.get<bool>("PassAllEvents", true);
  fPTBModuleLabel = p.get<std::string>("PTBModuleLabel", "daq");
  fPTBInstanceName = p.get<std::string>("PTBInstanceName", "TRIGGER");
  fVerbose = p.get<bool>("Verbose", false);
  fPrintPayloadInfo = p.get<bool>("PrintPayloadInfo", false);
  fInsertTriggerResultBool = p.get<bool>("InsertTriggerResultBool", false);
  fInvertTriggerDecision = p.get<bool>("InvertTriggerDecision", false);

  fFilterOnTriggerType = p.get<bool>("FilterOnTriggerType", false);
  fTriggerType = p.get<lbne::PennMicroSlice::Payload_Trigger::trigger_type_t>("TriggerType", 0x00);
  fTriggerTypeName = lbne::PennMicroSlice::Payload_Trigger::getTriggerName(fTriggerType);

  fFilterOnTriggerPattern = p.get<bool>("FilterOnTriggerPattern", false);
  fTriggerPatternBit = p.get<lbne::PennMicroSlice::Payload_Trigger::trigger_type_t>("TriggerPatternBit", 1);
  fTriggerPatternBitName = lbne::PennMicroSlice::Payload_Trigger::getTriggerName(fTriggerPatternBit);

  //setup TriggerPatternNames

  fFilterOnCounterPattern = p.get<bool>("FilterOnCounterPattern", false);
  /*
    I thought it was easier to set bit masks in binary in the FCL
    This reads the bitmasks in as strings, converts them to bitsets (which are binary representations), the final values are stored in counter_set_t's
    The storage type (counter_set_t's) makes them relatively easy to compare to the CounterPayload's
   */
  fCounter_Pattern_bitset_tsu_wu     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_wu   > (p.get<std::string>("Counter_Pattern_tsu_wu"   ,"0"));
  fCounter_Pattern_bitset_tsu_el     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_el   > (p.get<std::string>("Counter_Pattern_tsu_el"   ,"0"));
  fCounter_Pattern_bitset_tsu_extra  = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_extra> (p.get<std::string>("Counter_Pattern_tsu_extra","0"));
  fCounter_Pattern_bitset_tsu_nu     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nu   > (p.get<std::string>("Counter_Pattern_tsu_nu"   ,"0"));
  fCounter_Pattern_bitset_tsu_sl     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_sl   > (p.get<std::string>("Counter_Pattern_tsu_sl"   ,"0"));
  fCounter_Pattern_bitset_tsu_nl     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nl   > (p.get<std::string>("Counter_Pattern_tsu_nl"   ,"0"));
  fCounter_Pattern_bitset_tsu_su     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_su   > (p.get<std::string>("Counter_Pattern_tsu_su"   ,"0"));
  fCounter_Pattern_bitset_bsu_rm     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rm   > (p.get<std::string>("Counter_Pattern_bsu_rm"   ,"0"));
  fCounter_Pattern_bitset_bsu_cu     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cu   > (p.get<std::string>("Counter_Pattern_bsu_cu"   ,"0"));
  fCounter_Pattern_bitset_bsu_cl     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cl   > (p.get<std::string>("Counter_Pattern_bsu_cl"   ,"0"));
  fCounter_Pattern_bitset_bsu_rl     = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rl   > (p.get<std::string>("Counter_Pattern_bsu_rl"   ,"0"));

  fCounter_Pattern_tsu_wu    = fCounter_Pattern_bitset_tsu_wu.to_ulong();   
  fCounter_Pattern_tsu_el    = fCounter_Pattern_bitset_tsu_el.to_ulong();      
  fCounter_Pattern_tsu_extra = fCounter_Pattern_bitset_tsu_extra.to_ulong();   
  fCounter_Pattern_tsu_nu    = fCounter_Pattern_bitset_tsu_nu.to_ulong();      
  fCounter_Pattern_tsu_sl    = fCounter_Pattern_bitset_tsu_sl.to_ulong();      
  fCounter_Pattern_tsu_nl    = fCounter_Pattern_bitset_tsu_nl.to_ulong();      
  fCounter_Pattern_tsu_su    = fCounter_Pattern_bitset_tsu_su.to_ulong();      
  fCounter_Pattern_bsu_rm    = fCounter_Pattern_bitset_bsu_rm.to_ulong();      
  fCounter_Pattern_bsu_cu    = fCounter_Pattern_bitset_bsu_cu.to_ulong();      
  fCounter_Pattern_bsu_cl    = fCounter_Pattern_bitset_bsu_cl.to_ulong();      
  fCounter_Pattern_bsu_rl    = fCounter_Pattern_bitset_bsu_rl.to_ulong();      


  produces< bool >(); // The world's simplest trigger decision

}

void trig::PennBoardTrigger::printParams(){

  std::ostringstream my_ostringstream;
  
  for(int i=0;i<80;i++) my_ostringstream << "=";
  my_ostringstream << std::endl;

  my_ostringstream << "fPassAllEvents: " << fPassAllEvents << std::endl;
  my_ostringstream << "fPTBModuleLabel: " << fPTBModuleLabel << std::endl;
  my_ostringstream << "fPTBInstanceName: " << fPTBInstanceName << std::endl;
  my_ostringstream << std::endl;

  my_ostringstream << "fVerbose: " << fVerbose << std::endl;  
  my_ostringstream << "fPrintPayloadInfo: " << fPrintPayloadInfo << std::endl;  
  my_ostringstream << "fInsertTriggerResultBool: " << fInsertTriggerResultBool << std::endl;
  my_ostringstream << "fInvertTriggerDecision: " << fInvertTriggerDecision << std::endl;
  my_ostringstream << std::endl;

  my_ostringstream << "fFilterOnTriggerType: " << fFilterOnTriggerType << std::endl;
  if(fFilterOnTriggerType){
    my_ostringstream << "fTriggerType: 0x" << std::hex << static_cast<int>(fTriggerType) << std::dec << std::endl;
    my_ostringstream << "fTriggerTypeName: " << fTriggerTypeName << std::endl;
    my_ostringstream << std::endl;
  }

  my_ostringstream << "fFilterOnTriggerPattern: " << fFilterOnTriggerPattern << std::endl;
  if(fFilterOnTriggerPattern){
    my_ostringstream << "fTriggerPatternBit: " << fTriggerPatternBit << std::endl;
    my_ostringstream << "fTriggerPatternBitName: " << fTriggerPatternBitName << std::endl;
    my_ostringstream << std::endl;
  }

  my_ostringstream << "fFilterOnCounterPattern: "    << fFilterOnCounterPattern    << std::endl;
  if(fFilterOnCounterPattern){
    my_ostringstream << "fCounter_Pattern_tsu_wu:    " << fCounter_Pattern_bitset_tsu_wu    << std::endl;
    my_ostringstream << "fCounter_Pattern_tsu_el:    " << fCounter_Pattern_bitset_tsu_el    << std::endl;
    my_ostringstream << "fCounter_Pattern_tsu_extra: " << fCounter_Pattern_bitset_tsu_extra << std::endl;
    my_ostringstream << "fCounter_Pattern_tsu_nu:    " << fCounter_Pattern_bitset_tsu_nu    << std::endl;
    my_ostringstream << "fCounter_Pattern_tsu_sl:    " << fCounter_Pattern_bitset_tsu_sl    << std::endl;
    my_ostringstream << "fCounter_Pattern_tsu_nl:    " << fCounter_Pattern_bitset_tsu_nl    << std::endl;
    my_ostringstream << "fCounter_Pattern_tsu_su:    " << fCounter_Pattern_bitset_tsu_su    << std::endl;
    my_ostringstream << "fCounter_Pattern_bsu_rm:    " << fCounter_Pattern_bitset_bsu_rm    << std::endl;
    my_ostringstream << "fCounter_Pattern_bsu_cu:    " << fCounter_Pattern_bitset_bsu_cu    << std::endl;
    my_ostringstream << "fCounter_Pattern_bsu_cl:    " << fCounter_Pattern_bitset_bsu_cl    << std::endl;
    my_ostringstream << "fCounter_Pattern_bsu_rl:    " << fCounter_Pattern_bitset_bsu_rl    << std::endl;
  }
  for(int i=0;i<80;i++) my_ostringstream << "=";
  my_ostringstream << std::endl;

  std::cerr << my_ostringstream.str();

}

bool trig::PennBoardTrigger::filter(art::Event & evt)
{

  art::Handle<artdaq::Fragments> rawPTB;
  evt.getByLabel(fPTBModuleLabel,fPTBInstanceName,rawPTB);

  
  bool triggerDecision=false;

  if(fFilterOnTriggerType) 
    triggerDecision=filterOnTriggerPayload(rawPTB);
  else if(fFilterOnCounterPattern) 
    triggerDecision=filterOnCounterPayload(rawPTB);
  else if(fPrintPayloadInfo) 
    printPayloadInfo(rawPTB);

  if(fInvertTriggerDecision)
    triggerDecision = !(triggerDecision);

  
  if(fInsertTriggerResultBool)   evt.put(std::move(std::unique_ptr<bool>(new bool(triggerDecision))));

  if(fPassAllEvents) return true;
  return (triggerDecision);
}

bool trig::PennBoardTrigger::filterOnCounterPayload(art::Handle<artdaq::Fragments> const & rawPTB){

  if(rawPTB.isValid()){
    std::ostringstream my_ostringstream;
    for(int i=0;i<80;i++) my_ostringstream << "=";
    my_ostringstream << std::endl;
    my_ostringstream << "INFO : filterOnCounterPayload" << std::endl;
    for(int i=0;i<80;i++) my_ostringstream << "=";
    my_ostringstream << std::endl;

    if(fVerbose) std::cerr << my_ostringstream.str();
    my_ostringstream.str("");
    my_ostringstream.clear();

    for (size_t frag_index=0; frag_index < rawPTB->size(); ++frag_index){
      const auto & frag((*rawPTB)[frag_index]); //Make a fragment from the frag_index element of rawPTB
      lbne::PennMilliSliceFragment ms_frag(frag);
      lbne::PennMilliSlice::Header::payload_count_t n_frames, n_frames_counter, n_frames_trigger, n_frames_timestamp;
      n_frames = ms_frag.payloadCount(n_frames_counter, n_frames_trigger, n_frames_timestamp);
      
      lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type;
      lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp;
      uint8_t* payload_data=0;
      size_t payload_size=0;    
      
      //iterate through the frames
      for(uint32_t payload_index = 0; payload_index < n_frames; payload_index++){
        payload_data = ms_frag.get_next_payload(payload_index, payload_type, timestamp, payload_size);
        //The following should not happen, but just in case the get_next_payload runs off the end of the payload buffer
        if(payload_data==nullptr) continue;
    
        if(payload_type == lbne::PennMicroSlice::DataTypeCounter){
	  lbne::PennMicroSlice::Payload_Counter* myCounterPayload = lbne::reinterpret_cast_checked<lbne::PennMicroSlice::Payload_Counter*>(payload_data);
	  
	  bool triggerDecision=false;

	  //First idea is to perform an and with the counterpayload bits and the requested trigger bits
          if( fCounter_Pattern_tsu_wu    & (myCounterPayload->tsu_wu    )) triggerDecision = true;
          if( fCounter_Pattern_tsu_el    & (myCounterPayload->tsu_el    )) triggerDecision = true;
          if( fCounter_Pattern_tsu_extra & (myCounterPayload->tsu_extra )) triggerDecision = true;
          if( fCounter_Pattern_tsu_nu    & (myCounterPayload->tsu_nu    )) triggerDecision = true;
          if( fCounter_Pattern_tsu_sl    & (myCounterPayload->tsu_sl    )) triggerDecision = true;
          if( fCounter_Pattern_tsu_nl    & (myCounterPayload->tsu_nl    )) triggerDecision = true;
          if( fCounter_Pattern_tsu_su    & (myCounterPayload->tsu_su    )) triggerDecision = true;
          if( fCounter_Pattern_bsu_rm    & (myCounterPayload->bsu_rm    )) triggerDecision = true;
          if( fCounter_Pattern_bsu_cu    & (myCounterPayload->bsu_cu    )) triggerDecision = true;
          if( fCounter_Pattern_bsu_cl    & (myCounterPayload->get_bsu_cl()    )) triggerDecision = true;
          if( fCounter_Pattern_bsu_rl    & (myCounterPayload->bsu_rl    )) triggerDecision = true;

	  // my_ostringstream << "tsu_wu                 : " 
	  // 		   << std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_wu> (fCounter_Pattern_tsu_wu)    << std::endl;
	  // my_ostringstream << "CounterPayload->ts_wu  : " 
	  // 		   << std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_wu> (myCounterPayload->tsu_wu)    << std::endl;
	  // my_ostringstream << "&                      : " 
	  // 		   << std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_wu> ((myCounterPayload->tsu_wu) & fCounter_Pattern_tsu_wu) 
	  // 		   << " - ";
	  // if((myCounterPayload->tsu_wu) & fCounter_Pattern_tsu_wu) my_ostringstream << "TRUE";
	  // my_ostringstream << std::endl;

	  if(triggerDecision){
	    if(fVerbose){
	      my_ostringstream << "PASS -" 
			       << " frag_index: " << frag_index
			       << " payload_index: " << payload_index
			       << std::endl;
	      std::cerr << my_ostringstream.str();
	      my_ostringstream.str("");
	      my_ostringstream.clear();
	    }
	    return true;
	  }//triggerDecision
	}//DataTyhpeCounter
      }//payload_index
    }//frag_index
    my_ostringstream << "FAIL" << std::endl;

    if(fVerbose) std::cerr << my_ostringstream.str();
    my_ostringstream.str("");
    my_ostringstream.clear();

  }//isvalid
  return false;
}//filterOnCounterPayload;

bool trig::PennBoardTrigger::filterOnTriggerPayload(art::Handle<artdaq::Fragments> const & rawPTB){

  if(rawPTB.isValid()){
    std::ostringstream my_ostringstream;
    for(int i=0;i<80;i++) my_ostringstream << "=";
    my_ostringstream << std::endl;
    my_ostringstream << "INFO : FilterOnTriggerType: " << fFilterOnTriggerType
		     << " FilterOnTriggerPattern: " << fFilterOnTriggerPattern
		     << std::endl;
    for(int i=0;i<80;i++) my_ostringstream << "=";
    my_ostringstream << std::endl;

    if(fVerbose) std::cerr << my_ostringstream.str();
    my_ostringstream.str("");
    my_ostringstream.clear();

    for (size_t frag_index=0; frag_index < rawPTB->size(); ++frag_index){
      const auto & frag((*rawPTB)[frag_index]); //Make a fragment from the frag_index element of rawPTB
      lbne::PennMilliSliceFragment ms_frag(frag);
      lbne::PennMilliSlice::Header::payload_count_t n_frames, n_frames_counter, n_frames_trigger, n_frames_timestamp;
      n_frames = ms_frag.payloadCount(n_frames_counter, n_frames_trigger, n_frames_timestamp);
      
      lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type;
      lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp;
      uint8_t* payload_data=0;
      size_t payload_size=0;    
      
      //iterate through the frames
      for(uint32_t payload_index = 0; payload_index < n_frames; payload_index++){
        payload_data = ms_frag.get_next_payload(payload_index, payload_type, timestamp, payload_size);
        //The following should not happen, but just in case the get_next_payload runs off the end of the payload buffer
        if(payload_data==nullptr) continue;
    
        if(payload_type == lbne::PennMicroSlice::DataTypeTrigger){
    
          lbne::PennMicroSlice::Payload_Trigger *myTriggerPayload = lbne::reinterpret_cast_checked<lbne::PennMicroSlice::Payload_Trigger*>(payload_data);      
          std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_type> this_trigger_type;
          std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_id_muon> this_trigger_pattern;
    
          this_trigger_type = std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_type>(myTriggerPayload->trigger_type);
          this_trigger_pattern = std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_id_muon> (myTriggerPayload->trigger_id_muon);
          
          if((myTriggerPayload->trigger_type) == fTriggerType){
            if(fFilterOnTriggerPattern){
              if(this_trigger_pattern.test(fTriggerPatternBit)){
		my_ostringstream << "PASS -" 
				 << " frag_index: " << frag_index
				 << " payload_index: " << payload_index
				 << std::endl;
                // my_ostringstream << "PASS - myTriggerPayload->trigger_pattern bit " << fTriggerPatternBit << " == 1" << std::endl;
                // my_ostringstream << "PASS - payload_index:    " << payload_index << std::endl;
                // my_ostringstream << "PASS - trigger_type:    " << this_trigger_type << std::endl;
                // my_ostringstream << "PASS - timestamp:       " << timestamp << std::endl;
                // my_ostringstream << "PASS - trigger_pattern: " << this_trigger_pattern << std::endl;
                // my_ostringstream << std::endl;
                if(fVerbose) std::cerr << my_ostringstream.str();
                my_ostringstream.str("");
                my_ostringstream.clear();
    
                return true;
              }
              else{
                // my_ostringstream << "    FAIL - myTriggerPayload->trigger_pattern bit " << fTriggerPatternBit << " != 1" << std::endl;
                // my_ostringstream << "    FAIL - payload_index:    " << payload_index << std::endl;
                // my_ostringstream << "    FAIL - trigger_type:    " << this_trigger_type << std::endl;
                // my_ostringstream << "    FAIL - timestamp:       " << timestamp << std::endl;
                // my_ostringstream << "    FAIL - trigger_pattern: " << this_trigger_pattern << std::endl;
                // my_ostringstream << std::endl;
                if(fVerbose) std::cerr << my_ostringstream.str();
                my_ostringstream.str("");
                my_ostringstream.clear();
    
              }//this_trigger_pattern.test(fTriggerPatternBit) == false
            }//fFilterOnTriggerPattern == true
            else{
	      my_ostringstream << "PASS -" 
			       << " frag_index: " << frag_index
			       << " payload_index: " << payload_index
			       << std::endl;
              // my_ostringstream << "PASS - myTriggerPayload->trigger_type == trigger_type" << std::endl;
              // my_ostringstream << "PASS - payload_index:    " << payload_index << std::endl;
              // my_ostringstream << "PASS - trigger_type:    " << this_trigger_type << std::endl;
              // my_ostringstream << "PASS - timestamp:       " << timestamp << std::endl;
              // my_ostringstream << "PASS - trigger_pattern: " << this_trigger_pattern << std::endl;
              // my_ostringstream << std::endl;
              if(fVerbose) std::cerr << my_ostringstream.str();
              my_ostringstream.str("");
              my_ostringstream.clear();
    
              return true;          
            }//fFilterOnTriggerPattern == false
          }
          else
            {
              // my_ostringstream << "    FAIL - myTriggerPayload->trigger_type != trigger_type" << std::endl;
              // my_ostringstream << "    FAIL - payload_index:    " << payload_index << std::endl;
              // my_ostringstream << "    FAIL - trigger_type:    " << this_trigger_type << std::endl;
              // my_ostringstream << "    FAIL - timestamp:       " << timestamp << std::endl;
              // my_ostringstream << "    FAIL - trigger_pattern: " << this_trigger_pattern << std::endl;
              // my_ostringstream << std::endl;
              if(fVerbose) std::cerr << my_ostringstream.str();
              my_ostringstream.str("");
              my_ostringstream.clear();
    
            }
        }//DataTypeTrigger
      }//payload_index
    }//frag_index
    my_ostringstream << "FAIL" << std::endl;
    if(fVerbose) std::cerr << my_ostringstream.str();
  }//rawPTB.isValid
  return false;
}//filterOnTriggerType

void trig::PennBoardTrigger::printPayloadInfo(art::Handle<artdaq::Fragments> const & rawPTB){

  if(rawPTB.isValid()){
    std::cerr << "INFO : Got Valid PTB fragments" << std::endl;
    std::cerr << "INFO : Got PTB art::Handle<artdaq::Fragments>" << std::endl;
    std::cerr << std::endl;
    // checkGetNextPayload(rawPTB);

    /*
      Loop over the fragments found.
      Make a PennMilliSliceFragment from each
      Check the number of payloads of each type within the fragement (referred to as 'frames')
      Get each payload in turn and check its type
      The Trigger and Counter types are of interest, so in that case we'll do something
      We should extract the bit patterns. Not sure on the best way to do this!
     */

    for (size_t frag_index=0; frag_index < rawPTB->size(); ++frag_index){
      const auto & frag((*rawPTB)[frag_index]); //Make a fragment from the frag_index element of rawPTB
      lbne::PennMilliSliceFragment ms_frag(frag);
      lbne::PennMilliSlice::Header::payload_count_t n_frames, n_frames_counter, n_frames_trigger, n_frames_timestamp;
      n_frames = ms_frag.payloadCount(n_frames_counter, n_frames_trigger, n_frames_timestamp);
      
      //Information within the penn_payloads
      lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type;
      lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp;
      uint8_t* payload_data;
      size_t payload_size;
      
      //      PTBTrigger *myPTBTrigger;
      //      PTBCounter *myPTBCounter;
      lbne::PennMicroSlice::Payload_Counter *myCounterPayload;
      lbne::PennMicroSlice::Payload_Trigger *myTriggerPayload;

      std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_type> trigger_type;
      std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_id_muon> trigger_pattern;

      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_wu   > counter_bitset_tsu_wu       ;//tsu_wu     : 10
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_el   > counter_bitset_tsu_el       ;//tsu_el     : 10
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_extra> counter_bitset_tsu_extra    ;//tsu_extra  :  4
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nu   > counter_bitset_tsu_nu       ;//tsu_nu     :  6
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_sl   > counter_bitset_tsu_sl       ;//tsu_sl     :  6
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nl   > counter_bitset_tsu_nl       ;//tsu_nl     :  6
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_su   > counter_bitset_tsu_su       ;//tsu_su     :  6
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rm   > counter_bitset_bsu_rm       ;//bsu_rm     : 16
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cu   > counter_bitset_bsu_cu       ;//bsu_cu     : 10
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cl   > counter_bitset_bsu_cl       ;//bsu_cl     : 13
      std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rl   > counter_bitset_bsu_rl       ;//bsu_rl     : 10
                             
      //iterate through the frames             
      for (uint32_t payload_index = 0; payload_index < n_frames; payload_index++){
    payload_data = ms_frag.payload(payload_index, payload_type, timestamp, payload_size);
    
    if (payload_data == nullptr ){
      std::cerr << "payload_data == nullptr" << std::endl;
    }
    
    switch ( payload_type )
      {
      case lbne::PennMicroSlice::DataTypeCounter:
        std::cerr << "payload_type: Counter   "   << std::endl;
        std::cerr << "payload_size: " << payload_size << std::endl;

        //        myPTBCounter = lbne::reinterpret_cast_checked<PTBCounter*>(payload_data);
        myCounterPayload = lbne::reinterpret_cast_checked<lbne::PennMicroSlice::Payload_Counter*>(payload_data);

        std::cerr << "myCounterPayload size: " << sizeof(*myCounterPayload) << std::endl;
        //        std::cerr << "myCounterPayload size: " << sizeof(PTBCounter) << std::endl;
        std::cerr << "myCounterPayload size: " << sizeof(lbne::PennMicroSlice::Payload_Counter) << std::endl;

        counter_bitset_tsu_wu       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_wu   >(myCounterPayload->tsu_wu      );// tsu_wu     : 10
        counter_bitset_tsu_el       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_el   >(myCounterPayload->tsu_el      );// tsu_el     : 10
        counter_bitset_tsu_extra    = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_extra>(myCounterPayload->tsu_extra   );// tsu_extra  :  4
        counter_bitset_tsu_nu       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nu   >(myCounterPayload->tsu_nu      );// tsu_nu     :  6
        counter_bitset_tsu_sl       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_sl   >(myCounterPayload->tsu_sl      );// tsu_sl     :  6
        counter_bitset_tsu_nl       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_nl   >(myCounterPayload->tsu_nl      );// tsu_nl     :  6
        counter_bitset_tsu_su       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_tsu_su   >(myCounterPayload->tsu_su      );// tsu_su     :  6
        counter_bitset_bsu_rm       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rm   >(myCounterPayload->bsu_rm      );// bsu_rm     : 16
        counter_bitset_bsu_cu       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cu   >(myCounterPayload->bsu_cu      );// bsu_cu     : 10
        counter_bitset_bsu_cl       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_cl   >(myCounterPayload->get_bsu_cl()      );// bsu_cl     : 13
        counter_bitset_bsu_rl       = std::bitset<lbne::PennMicroSlice::Payload_Counter::num_bits_bsu_rl   >(myCounterPayload->bsu_rl      );// bsu_rl     : 10

        std::cerr << "tsu_wu      : " << counter_bitset_tsu_wu      << std::endl;
        std::cerr << "tsu_el      : " << counter_bitset_tsu_el      << std::endl;
        std::cerr << "tsu_extra   : " << counter_bitset_tsu_extra   << std::endl;
        std::cerr << "tsu_nu      : " << counter_bitset_tsu_nu      << std::endl;
        std::cerr << "tsu_sl      : " << counter_bitset_tsu_sl      << std::endl;
        std::cerr << "tsu_nl      : " << counter_bitset_tsu_nl      << std::endl;
        std::cerr << "tsu_su      : " << counter_bitset_tsu_su      << std::endl;
        std::cerr << "bsu_rm      : " << counter_bitset_bsu_rm      << std::endl;
        std::cerr << "bsu_cu      : " << counter_bitset_bsu_cu      << std::endl;
        std::cerr << "bsu_cl      : " << counter_bitset_bsu_cl      << std::endl;
        std::cerr << "bsu_rl      : " << counter_bitset_bsu_rl      << std::endl;
        std::cerr << std::endl;

        break;
      case lbne::PennMicroSlice::DataTypeTrigger:
        std::cerr << "payload_type: Trigger   "   << std::endl;
        std::cerr << "payload_size: " << payload_size << std::endl;

        //        myPTBTrigger = lbne::reinterpret_cast_checked<PTBTrigger*>(payload_data);
        myTriggerPayload = lbne::reinterpret_cast_checked<lbne::PennMicroSlice::Payload_Trigger*>(payload_data);

        trigger_type = std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_type>(myTriggerPayload->trigger_type);
        trigger_pattern = std::bitset<lbne::PennMicroSlice::Payload_Trigger::num_bits_trigger_id_muon> (myTriggerPayload->trigger_id_muon);
        std::cerr << "trigger_type:    " << trigger_type << std::endl;
        std::cerr << "trigger_pattern: " << trigger_pattern << std::endl;


        switch ( myTriggerPayload->trigger_type ){
        case lbne::PennMicroSlice::Payload_Trigger::calibration:
          std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerTypes::calibration" << std::endl;
          break;
        case lbne::PennMicroSlice::Payload_Trigger::ssp:
          std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerTypes::ssp" << std::endl;
          break;
        case lbne::PennMicroSlice::Payload_Trigger::muon:
          std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerTypes::muon" << std::endl;

          if(trigger_pattern.test(lbne::PennMicroSlice::Payload_Trigger::TA)) 
        std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerPatternBits::bsu_rm_cl" << std::endl;
          if(trigger_pattern.test(lbne::PennMicroSlice::Payload_Trigger::TB)) 
        std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerPatternBits::tsu_nu_sl" << std::endl;
          if(trigger_pattern.test(lbne::PennMicroSlice::Payload_Trigger::TC)) 
        std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerPatternBits::tsu_sl_nu" << std::endl;
          if(trigger_pattern.test(lbne::PennMicroSlice::Payload_Trigger::TD)) 
        std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerPatternBits::tsu_el_wu" << std::endl;
          break;
        default:
          std::cerr << "lbne::PennMicroSlice::Payload_Trigger::TriggerTypes::unkown" << std::endl;
          break;
        }//switch( myTriggerPayload->trigger_type)

        break;
      case lbne::PennMicroSlice::DataTypeTimestamp:
        std::cerr << "payload_type: Timestamp " << std::endl;
        std::cerr << "payload_size: " << payload_size << std::endl;
        break;
      case lbne::PennMicroSlice::DataTypeWarning:
        std::cerr << "payload_type: Selftest  "  << std::endl;
        std::cerr << "payload_size: " << payload_size << std::endl;
        break;
      case lbne::PennMicroSlice::DataTypeChecksum:
        std::cerr << "payload_type: Checksum  "  << std::endl;
        std::cerr << "payload_size: " << payload_size << std::endl;
        break;
      default:
        std::cerr << "payload_type: Unknown   "  << std::endl;
        std::cerr << "payload_size: " << payload_size << std::endl;
        break;
      }//switch(payload_type)
    std::cerr << std::endl;
      }//payload_index
    }//frag_index
  }//isValid
  else{
    std::cerr << "INFO : NOT Got Valid PTB fragments" << std::endl;
  }
}

void trig::PennBoardTrigger::checkGetNextPayload(art::Handle<artdaq::Fragments> const & rawPTB){
  for (size_t frag_index=0; frag_index < rawPTB->size(); ++frag_index){
    const auto & frag((*rawPTB)[frag_index]); //Make a fragment from the frag_index element of rawPTB
    lbne::PennMilliSliceFragment ms_frag(frag);
    lbne::PennMilliSlice::Header::payload_count_t n_frames, n_frames_counter, n_frames_trigger, n_frames_timestamp;
    n_frames = ms_frag.payloadCount(n_frames_counter, n_frames_trigger, n_frames_timestamp);

    lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type;
    lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp;
    uint8_t* payload_data;
    size_t payload_size;

    lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type_get_next;
    lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp_get_next;
    uint8_t* payload_data_get_next;
    size_t payload_size_get_next;
    
    
    uint32_t payload_index_get_next=0;
    //iterate through the frames
    for (uint32_t payload_index = 0; payload_index < n_frames; payload_index++){
      payload_data = ms_frag.payload(payload_index, payload_type, timestamp, payload_size);
      payload_data_get_next = ms_frag.get_next_payload(payload_index_get_next, payload_type_get_next, timestamp_get_next, payload_size_get_next);
    
      if(payload_data_get_next == nullptr){
    std::cerr << "ERROR - payload_data_get_next == nullptr" << std::endl;
    return;
      }

      if(payload_index != payload_index_get_next) {
    std::cerr << "MISSMATCH - payload_index != payload_index_get_next" << std::endl;
      }
      else if(payload_data != payload_data_get_next){
    std::cerr << "MISSMATCH - payload_data != payload_data_get_next" << std::endl;
      }
      else if(payload_type != payload_type_get_next){
    std::cerr << "MISSMATCH - payload_type != payload_type_get_next" << std::endl;
      }
      else if(timestamp != timestamp_get_next){
    std::cerr << "MISSMATCH - timestamp != timestamp_get_next" << std::endl;
      }
      else if(payload_size != payload_size_get_next){
    std::cerr << "MISSMATCH - payload_size != payload_size_get_next" << std::endl;
      }
      else{
    std::cerr << "MATCH - payload_index: " << payload_index << std::endl;
      }
    }//payload_index
  }//frag_index
}

DEFINE_ART_MODULE(trig::PennBoardTrigger)
