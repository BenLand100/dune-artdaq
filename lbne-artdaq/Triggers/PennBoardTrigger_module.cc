////////////////////////////////////////////////////////////////////////
// Class:       PennBoardTrigger
// Module Type: filter
// File:        PennBoardTrigger_module.cc
//
// Generated at Fri Dec  5 10:21:00 2014 by Jonathan Davies using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <iomanip>
#include <bitset>

#include "artdaq-core/Data/Fragments.hh"
#include "lbne-raw-data/Overlays/PennMilliSliceFragment.hh"
#include "lbne-raw-data/Overlays/Utilities.hh"

namespace trig {
  class PennBoardTrigger;


  struct PTBTriggerPatternBits{
    static uint8_t const bsu_rm_cl = 26;
    static uint8_t const tsu_nu_sl = 25;
    static uint8_t const tsu_sl_nu = 24;
    static uint8_t const tsu_el_wu = 23;
  };
  struct PTBTriggerTypes{
    static uint32_t const calibration = 0x00;
    static uint32_t const ssp = 0x08;
    //FIXME not sure about the rce stuff!
    static uint32_t const rce_a = 0x01;
    static uint32_t const rce_b = 0x02;
    static uint32_t const rce_c = 0x04;
    static uint32_t const muon = 0x10;
    /*
      //From PTB Data Format v2.3 Nuno Baros DUNE Collaboration meeting September 2015
      00000 Calibration DAQ requested calibration pulse/ID of the pulsed systems
      01000 SSP         Trigger-in induced by the SSP/none
      00001 RCE         Trigger-in induced by the RCE (1 bit per unit)
      ...
      00111 RCE
      10000 Muon Panel  Counter trigger pattern ID
    */
  };

  struct PTBTrigger{
    uint32_t trigger_pattern: 27;
    uint32_t trigger_type: 5;
  };
  struct PTBCounter{
    uint64_t tsu_wu     : 10;
    uint64_t tsu_el     : 10;
    uint64_t tsu_extra  :  4;    
    uint64_t tsu_nu     :  6;
    uint64_t tsu_sl     :  6;
    uint64_t tsu_nl     :  6;
    uint64_t tsu_su     :  6;
    uint64_t bsu_rm     : 16;
    uint64_t bsu_cu     : 10;
    uint64_t bsu_cl     : 13;
    uint64_t bsu_rl     : 10;
    uint64_t ts_rollover: 28;
    uint64_t header     :  3;

    //tsu [47-0]
    /*
      TSU counter word to TSU counters:
      ---------------------------------

      TSU[47-42] : SU 6-1  (CCU2 : 24-19+48-43)
      TSU[41-36] : NL 6-1  (CCU2 : 18-13+42-37)
      TSU[35-30] : SL 6-1  (CCU2 : 12-7+36-31)
      TSU[29-24] : NU 6-1  (CCU2 : 6-1+30-25)
      
      TSU[23-20] : Extra   (CCU1 : 24-21+48-45)
      TSU[19-10] : EL 10-1 (CCU1 : 20-11+44-35)
      TSU[9-0]   : WU 10-1 (CCU1 : 10-1+34-25)
    */
    //bsu [96-48]
    /*
      BSU counter word to CCU counters:
      ---------------------------------
      
      BSU[48-39] : RL 10-1 (CCU3 : 48-39)
      BSU[38-32] : CL 13-7 (CCU3 : 38-32)
      BSU[31-26] : CL 6-1  (CCU4 : 16-11)
      BSU[25-16] : CU 10-1 (CCU4 : 10-1)
      BSU[15-0]  : RM 16-1 (CCU4 : 40-25)
    */

    //ts_rollover[124-97]
    //header[127-125]

    /*

#JPD - this looks like the REAL channel mapping - sent to Dominick Brailsford by nuno. Will implement next

## NOTE: 
========

The PTB has 50 input BSU channels. This was traced back in emails back to the beginning of the discussions. However, at the moment there are only 49 physical channels. Channel 32 in the PTB is not being used (would be ch 31 in CCU-3).

This means that the channels 33-49 are shifted in the output word becoming 32-48.


PTB Counter word bits to components
-----------------------------------

* Word has a total of 128 bits and contains:
   ++ 3 bits  : header mask
   ++ 28 bits : timestamp rollover (28 lab of timestamp)
   ++ 49 bits : BSU
   ++ 48 bits : TSU
 
word[127-125] : header[2-0]
word[124-97]  : ts_rollover[27-0]
word[96-48]   : BSU[48-0]
word[47-0]    : TSU[47-0]


BSU counter word to CCU counters:
---------------------------------

BSU[48-39] : RL 10-1 (CCU3 : 48-39)
BSU[38-32] : CL 13-7 (CCU3 : 38-32)
BSU[31-26] : CL 6-1  (CCU4 : 16-11)
BSU[25-16] : CU 10-1 (CCU4 : 10-1)
BSU[15-0]  : RM 16-1 (CCU4 : 40-25)


TSU counter word to TSU counters:
---------------------------------

TSU[47-42] : SU 6-1  (CCU2 : 24-19+48-43)
TSU[41-36] : NL 6-1  (CCU2 : 18-13+42-37)
TSU[35-30] : SL 6-1  (CCU2 : 12-7+36-31)
TSU[29-24] : NU 6-1  (CCU2 : 6-1+30-25)

TSU[23-20] : Extra   (CCU1 : 24-21+48-45)
TSU[19-10] : EL 10-1 (CCU1 : 20-11+44-35)
TSU[9-0]   : WU 10-1 (CCU1 : 10-1+34-25)
    */

  };
  
}

class trig::PennBoardTrigger : public art::EDFilter {
public:
  explicit PennBoardTrigger(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PennBoardTrigger(PennBoardTrigger const &) = delete;
  PennBoardTrigger(PennBoardTrigger &&) = delete;
  PennBoardTrigger & operator = (PennBoardTrigger const &) = delete;
  PennBoardTrigger & operator = (PennBoardTrigger &&) = delete;
  void beginJob();
  void checkGetNextPayload(art::Handle<artdaq::Fragments> const & rawPTB);


  // Required functions.
  bool filter(art::Event & evt) override;
  void printParams();

private:

  bool fIsPTB; 
  std::string fPTBModuleLabel;
  std::string fPTBInstanceName;

};


void trig::PennBoardTrigger::beginJob(){
  printParams();
}

trig::PennBoardTrigger::PennBoardTrigger(fhicl::ParameterSet const & p)
// Initialize member data here.
{

  fPTBModuleLabel = p.get<std::string>("PTBModuleLabel", "daq");
  fPTBInstanceName = p.get<std::string>("PTBInstanceName", "TRIGGER");
}

void trig::PennBoardTrigger::printParams(){
  
  for(int i=0;i<80;i++) std::cerr << "=";
  std::cerr << std::endl;
  std::cerr << "fPTBModuleLabel: " << fPTBModuleLabel << std::endl;
  std::cerr << "fPTBInstanceName: " << fPTBInstanceName << std::endl;
  for(int i=0;i<80;i++) std::cerr << "=";
  std::cerr << std::endl;


}

void trig::PennBoardTrigger::checkGetNextPayload(art::Handle<artdaq::Fragments> const & rawPTB){
  

  for (size_t frag_index=0; frag_index < rawPTB->size(); ++frag_index){
    const auto & frag((*rawPTB)[frag_index]); //Make a fragment from the frag_index element of rawPTB
    lbne::PennMilliSliceFragment ms_frag(frag);
    lbne::PennMilliSlice::Header::payload_count_t n_frames, n_frames_counter, n_frames_trigger, n_frames_timestamp;
    n_frames = ms_frag.payloadCount(n_frames_counter, n_frames_trigger, n_frames_timestamp);

    lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type;
    lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp;
    uint8_t* payload_data;
    size_t payload_size;

    lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type_get_next;
    lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp_get_next;
    uint8_t* payload_data_get_next;
    size_t payload_size_get_next;
    
    
    uint32_t payload_index_get_next=0;
    //iterate through the frames
    for (uint32_t payload_index = 0; payload_index < n_frames; payload_index++){
      payload_data = ms_frag.payload(payload_index, payload_type, timestamp, payload_size);
      payload_data_get_next = ms_frag.get_next_payload(payload_index_get_next, payload_type_get_next, timestamp_get_next, payload_size_get_next);
    
      if(payload_data_get_next == nullptr){
	std::cerr << "ERROR - payload_data_get_next == nullptr" << std::endl;
	return;
      }

      if(payload_index != payload_index_get_next) {
	std::cerr << "MISSMATCH - payload_index != payload_index_get_next" << std::endl;
      }
      else if(payload_data != payload_data_get_next){
	std::cerr << "MISSMATCH - payload_data != payload_data_get_next" << std::endl;
      }
      else if(payload_type != payload_type_get_next){
	std::cerr << "MISSMATCH - payload_type != payload_type_get_next" << std::endl;
      }
      else if(timestamp != timestamp_get_next){
	std::cerr << "MISSMATCH - timestamp != timestamp_get_next" << std::endl;
      }
      else if(payload_size != payload_size_get_next){
	std::cerr << "MISSMATCH - payload_size != payload_size_get_next" << std::endl;
      }
      else{
	std::cerr << "MATCH - payload_index: " << payload_index << std::endl;
      }
    }//payload_index
  }//frag_index
}


bool trig::PennBoardTrigger::filter(art::Event & evt)
{
  // Implementation of required member function here.
  auto eventID = evt.id();

  art::Handle<artdaq::Fragments> rawPTB;
  fIsPTB=true;
  evt.getByLabel("daq","TRIGGER",rawPTB);
  //  evt.getByLabel(fPTBModuleLabel,fPTBInstanceName,rawPTB);

  if(rawPTB.isValid()){
    std::cerr << "INFO : Got Valid PTB fragments" << std::endl;
    std::cerr << "INFO : Got PTB art::Handle<artdaq::Fragments>" << std::endl;
    std::cerr << "INFO : eventID: " << eventID << std::endl;
    std::cerr << std::endl;
    // checkGetNextPayload(rawPTB);

    /*
      Loop over the fragments found.
      Make a PennMilliSliceFragment from each
      Check the number of payloads of each type within the fragement (referred to as 'frames')
      Get each payload in turn and check its type
      The Trigger and Counter types are of interest, so in that case we'll do something
      We should extract the bit patterns. Not sure on the best way to do this!
     */

    for (size_t frag_index=0; frag_index < rawPTB->size(); ++frag_index){
      const auto & frag((*rawPTB)[frag_index]); //Make a fragment from the frag_index element of rawPTB
      lbne::PennMilliSliceFragment ms_frag(frag);
      lbne::PennMilliSlice::Header::payload_count_t n_frames, n_frames_counter, n_frames_trigger, n_frames_timestamp;
      n_frames = ms_frag.payloadCount(n_frames_counter, n_frames_trigger, n_frames_timestamp);
      
      //Information within the penn_payloads
      lbne::PennMicroSlice::Payload_Header::data_packet_type_t payload_type;
      lbne::PennMicroSlice::Payload_Header::short_nova_timestamp_t timestamp;
      uint8_t* payload_data;
      size_t payload_size;
      
      PTBTrigger *myPTBTrigger;
      //      PTBCounter *myPTBCounter;
      lbne::PennMilliSlice::CounterPayload *myCounterPayload;

      std::bitset<5> trigger_type;
      std::bitset<27> trigger_pattern;

      std::bitset<10> counter_bitset_tsu_wu       ;//tsu_wu     : 10
      std::bitset<10> counter_bitset_tsu_el       ;//tsu_el     : 10
      std::bitset< 4> counter_bitset_tsu_extra    ;//tsu_extra  :  4
      std::bitset< 6> counter_bitset_tsu_nu       ;//tsu_nu     :  6
      std::bitset< 6> counter_bitset_tsu_sl       ;//tsu_sl     :  6
      std::bitset< 6> counter_bitset_tsu_nl       ;//tsu_nl     :  6
      std::bitset< 6> counter_bitset_tsu_su       ;//tsu_su     :  6
      std::bitset<16> counter_bitset_bsu_rm       ;//bsu_rm     : 16
      std::bitset<10> counter_bitset_bsu_cu       ;//bsu_cu     : 10
      std::bitset<13> counter_bitset_bsu_cl       ;//bsu_cl     : 13
      std::bitset<10> counter_bitset_bsu_rl       ;//bsu_rl     : 10
						     
      //iterate through the frames		     
      for (uint32_t payload_index = 0; payload_index < n_frames; payload_index++){
	payload_data = ms_frag.payload(payload_index, payload_type, timestamp, payload_size);
	
	if (payload_data == nullptr ){
	  std::cerr << "payload_data == nullptr" << std::endl;
	}
	
	switch ( payload_type )
	  {
	  case lbne::PennMicroSlice::DataTypeCounter:
	    std::cerr << "payload_type: Counter   "   << std::endl;
	    std::cerr << "payload_size: " << payload_size << std::endl;

	    //	    myPTBCounter = lbne::reinterpret_cast_checked<PTBCounter*>(payload_data);
	    myCounterPayload = lbne::reinterpret_cast_checked<lbne::PennMilliSlice::CounterPayload*>(payload_data);

	    std::cerr << "myCounterPayload size: " << sizeof(*myCounterPayload) << std::endl;
	    //	    std::cerr << "myCounterPayload size: " << sizeof(PTBCounter) << std::endl;
	    std::cerr << "myCounterPayload size: " << sizeof(lbne::PennMilliSlice::CounterPayload) << std::endl;

	    counter_bitset_tsu_wu       = std::bitset<10>(myCounterPayload->tsu_wu      );// tsu_wu     : 10
	    counter_bitset_tsu_el       = std::bitset<10>(myCounterPayload->tsu_el      );// tsu_el     : 10
	    counter_bitset_tsu_extra    = std::bitset< 4>(myCounterPayload->tsu_extra   );// tsu_extra  :  4
	    counter_bitset_tsu_nu       = std::bitset< 6>(myCounterPayload->tsu_nu      );// tsu_nu     :  6
	    counter_bitset_tsu_sl       = std::bitset< 6>(myCounterPayload->tsu_sl      );// tsu_sl     :  6
	    counter_bitset_tsu_nl       = std::bitset< 6>(myCounterPayload->tsu_nl      );// tsu_nl     :  6
	    counter_bitset_tsu_su       = std::bitset< 6>(myCounterPayload->tsu_su      );// tsu_su     :  6
	    counter_bitset_bsu_rm       = std::bitset<16>(myCounterPayload->bsu_rm      );// bsu_rm     : 16
	    counter_bitset_bsu_cu       = std::bitset<10>(myCounterPayload->bsu_cu      );// bsu_cu     : 10
	    counter_bitset_bsu_cl       = std::bitset<13>(myCounterPayload->bsu_cl      );// bsu_cl     : 13
	    counter_bitset_bsu_rl       = std::bitset<10>(myCounterPayload->bsu_rl      );// bsu_rl     : 10

	    std::cerr << "tsu_wu      : " << counter_bitset_tsu_wu      << std::endl;
	    std::cerr << "tsu_el      : " << counter_bitset_tsu_el      << std::endl;
	    std::cerr << "tsu_extra   : " << counter_bitset_tsu_extra   << std::endl;
	    std::cerr << "tsu_nu      : " << counter_bitset_tsu_nu      << std::endl;
	    std::cerr << "tsu_sl      : " << counter_bitset_tsu_sl      << std::endl;
	    std::cerr << "tsu_nl      : " << counter_bitset_tsu_nl      << std::endl;
	    std::cerr << "tsu_su      : " << counter_bitset_tsu_su      << std::endl;
	    std::cerr << "bsu_rm      : " << counter_bitset_bsu_rm      << std::endl;
	    std::cerr << "bsu_cu      : " << counter_bitset_bsu_cu      << std::endl;
	    std::cerr << "bsu_cl      : " << counter_bitset_bsu_cl      << std::endl;
	    std::cerr << "bsu_rl      : " << counter_bitset_bsu_rl      << std::endl;
	    std::cerr << std::endl;

	    break;
	  case lbne::PennMicroSlice::DataTypeTrigger:
	    std::cerr << "payload_type: Trigger   "   << std::endl;
	    std::cerr << "payload_size: " << payload_size << std::endl;

	    myPTBTrigger = lbne::reinterpret_cast_checked<PTBTrigger*>(payload_data);
	    trigger_type = std::bitset<5>(myPTBTrigger->trigger_type);
	    trigger_pattern = std::bitset<27> (myPTBTrigger->trigger_pattern);
	    std::cerr << "trigger_type:    " << trigger_type << std::endl;
	    std::cerr << "trigger_pattern: " << trigger_pattern << std::endl;


	    switch ( myPTBTrigger->trigger_type ){
	    case trig::PTBTriggerTypes::calibration:
	      std::cerr << "trig::PTBTriggerTypes::calibration" << std::endl;
	      break;
	    case trig::PTBTriggerTypes::ssp:
	      std::cerr << "trig::PTBTriggerTypes::ssp" << std::endl;
	      break;
	    case trig::PTBTriggerTypes::muon:
	      std::cerr << "trig::PTBTriggerTypes::muon" << std::endl;

	      if(trigger_pattern.test(trig::PTBTriggerPatternBits::bsu_rm_cl)) 
		std::cerr << "trig::PTBTriggerPatternBits::bsu_rm_cl" << std::endl;
	      if(trigger_pattern.test(trig::PTBTriggerPatternBits::tsu_nu_sl)) 
		std::cerr << "trig::PTBTriggerPatternBits::tsu_nu_sl" << std::endl;
	      if(trigger_pattern.test(trig::PTBTriggerPatternBits::tsu_sl_nu)) 
		std::cerr << "trig::PTBTriggerPatternBits::tsu_sl_nu" << std::endl;
	      if(trigger_pattern.test(trig::PTBTriggerPatternBits::tsu_el_wu)) 
		std::cerr << "trig::PTBTriggerPatternBits::tsu_el_wu" << std::endl;
	      break;
	    default:
	      std::cerr << "trig::PTBTriggerTypes::unkown" << std::endl;
	      break;
	    }//switch( myPTBTrigger->trigger_type)






	    break;
	  case lbne::PennMicroSlice::DataTypeTimestamp:
	    std::cerr << "payload_type: Timestamp " << std::endl;
	    std::cerr << "payload_size: " << payload_size << std::endl;
	    break;
	  case lbne::PennMicroSlice::DataTypeSelftest:
	    std::cerr << "payload_type: Selftest  "  << std::endl;
	    std::cerr << "payload_size: " << payload_size << std::endl;
	    break;
	  case lbne::PennMicroSlice::DataTypeChecksum:
	    std::cerr << "payload_type: Checksum  "  << std::endl;
	    std::cerr << "payload_size: " << payload_size << std::endl;
	    break;
	  default:
	    std::cerr << "payload_type: Unknown   "  << std::endl;
	    std::cerr << "payload_size: " << payload_size << std::endl;
	    break;
	  }//switch(payload_type)
	std::cerr << std::endl;
      }//payload_index
    }//frag_index
  }//isValid
  else{
    std::cerr << "INFO : NOT Got Valid PTB fragments" << std::endl;
  }

  return 1;
}




DEFINE_ART_MODULE(trig::PennBoardTrigger)
