# FHiCL document used to run the "driver" executable. To learn more
#  about the FHiCL language, please look at
#  cdcvs.fnal.gov/redmine/documents/327 , the "FHiCL Quick Start Guide"

events_to_generate: 2
run_number: 101

fragment_receiver: {

   # Parameters defining and configuring the fragment generator to be used
   		    
   generator: ToySimulator 
   fragment_type: TOY2        # Make sure downstream modules know about this fragment_type!
   nADCcounts: 100
   throttle_usecs: 5000000  # Wait this many usecs before creating the next event


   # Parameters configuring the fragment generator's parent class
   # artdaq::CommandableFragmentGenerator

   fragment_ids: [0]  # In the case of just one fragment, "fragment_id: 0" would also work
   board_id: 999 
}  		  

event_builder: {

  expected_fragments_per_event: 1
  use_art: true
  print_event_store_stats: false
  verbose: false
  events_expected_in_SimpleQueueReader: @local::events_to_generate
}

######################################################################
# The ART code
######################################################################

physics:
{
  analyzers:
  {
  
  # n.b. if you wish to generate more than one fragment per event, toyDump should be disabled

    toyDump:
    {
      module_type: ToyDump
      raw_data_label: daq
      frag_type: @local::fragment_receiver.fragment_type
      num_adcs_to_show: 10   # Obviously this should be no more than ADC counts per fragment
    }

    # A RootApplication module is needed for the WFViewer module's graphics capabilities

    app: {
    module_type: RootApplication
    force_new: true
    }


   wf: {
    module_type: WFViewer

    # Make sure there are as many fragment type labels as there are fragment IDs!

    fragment_ids: @local::fragment_receiver.fragment_ids
     fragment_type_labels: [ @local::fragment_receiver.fragment_type ]
    prescale: 1
    digital_sum_only: false
    }

  }

  producers:
  {
    lbneArtdaqBuildInfo:
    {
     module_type: LbneArtdaqBuildInfo
    }
  }   


  p: [ lbneArtdaqBuildInfo ] 

  a1: [ toyDump ]
  a2: [ app, wf ]

  e1: [ out1, rootout ]

  end_paths: [ p, a1, e1 ]
}

outputs:
{
  out1:
  {
    module_type: FileDumperOutput
    wantProductFriendlyClassName: true
  }

  rootout:
  {
    module_type: RootOutput
    fileName: "driver.root"
    compressionLevel: 0
  }

}

source:
{
module_type: RawInput
waiting_time: 900
resume_after_timeout: true
fragment_type_map: [[5, "TOY1"], [6, "TOY2"] ]
}

process_name: Driver



